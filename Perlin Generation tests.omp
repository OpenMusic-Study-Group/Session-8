; OM File Header - Saved 2020/11/01 13:27:51
; (6.17 :patc (om-make-point 138 475) (om-make-point -8 -8) (om-make-point 1280 597) "" 183 0 nil "2020/11/01 11:44:38")
; End File Header
(in-package :om)(load-lib-for (quote ("Alan")))(setf *om-current-persistent* (om-load-patch1 "Perlin Generation tests" (quote ((let ((box (om-load-boxcall (quote bastype) "list 8" (quote list) (quote nil) (om-make-point 284 80) (om-make-point 283 28) (list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20) "(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "BPC" (quote bpc) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "X coordinates (list)" "x-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "Y coordinates (list)" "y-points" (list 0 100)) (om-load-inputfun (quote input-funbox) "precision (integer) [0 - 10]" "decimals" 0))) (om-make-point 374 267) (om-make-point 110 77) (let ((newobj (when (find-class (quote bpc) nil) (let ((newbpf (simple-bpf-from-list (quote (0 100 200 300 400 500 600 700 800 900 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900)) (quote (1 0 0 1 1 0 0 1 1 0 1 0 1 0 0 1 0 0 1 1)) (quote bpc) 0))) (setf (bpfcolor newbpf) (om-make-color 0 0 0)) (set-name newbpf nil) newbpf)))) (when newobj) newobj) nil nil (pairlis (quote (picture winpos winsize)) (list nil (om-make-point 10 40) (om-make-point 728 255))) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pnoise" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 375 195) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "PERLIN-NOISE" (quote perlin-noise) (quote ((om-load-inputfun (quote input-funbox) "yet another test" "ARG1" 10) (om-load-inputfun (quote input-funbox) "yet another test" "ARG2" 10) (om-load-inputfun (quote input-funbox) "yet another test" "ARG3" 4) (om-load-inputfun (quote input-funbox) "yet another test" "ARG4" 4))) (om-make-point 91 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 80 132) (om-make-point 33 28) 10 "10" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 2 (om-make-point 190 46) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 109 38) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 460 316) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 10 160) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 496 425) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 396 425) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((6 0 0 0 nil 0) (1 0 0 1 nil 0) (3 0 0 2 nil 0) (2 0 0 3 nil 0) (0 0 5 0 nil 0) (4 0 6 0 nil 0) (5 1 7 0 nil 0) (5 0 8 0 nil 0))) 1 "pnoise" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 3" (quote t) (quote nil) (om-make-point 1064 421) (om-make-point 42 28) (list 15) "(15)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ 3" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 717 452) (om-make-point 342 169) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((3600) (2600) (5100) (6800) (6600) (5400) (5600) (3900) (5200) (5200) (3900) (5600) (5400) (6600) (6800) (5100) (2600) (3600) (3100) (4800) (3800) (5600) (5900) (5500) (5400) (3300) (3600))) :lonset (quote (0 182 287 572 980 1376 1686 2012 2212 2507 2802 3002 3328 3638 4034 4442 4727 4832 5014 5152 5417 5612 5930 6272 6586 6890 7044 7408)) :ldur (quote ((364) (210) (569) (816) (792) (620) (652) (402) (589) (589) (402) (652) (620) (792) (816) (569) (210) (364) (275) (531) (390) (636) (685) (626) (608) (309) (364))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15) (15))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.17 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point -8 -8) (om-make-point 1280 617) 0 1000 nil 1 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote gf) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux 2" (quote t) (quote nil) (om-make-point 613 347) (om-make-point 42 28) (list 15) "(15)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 1200) (om-load-inputfun (quote input-funbox) "end " "END" 8000) (om-load-inputfun (quote input-funbox) "step" "STEP" 100))) (om-make-point 856 93) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 721 250) (om-make-point 299 134) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6600) (6400) (6700) (7100) (7100) (6900) (6900) (6600) (6900) (6900) (6600) (6900) (6900) (7100) (7100) (6700) (6400) (6600) (6400) (6700) (6600) (6900) (6900) (6900) (6900) (6600) (6600))) :lonset (quote (0 1000 2000 3000 4000 5000 6000 7000 8000 9000 10000 11000 12000 13000 14000 15000 16000 17000 18000 19000 20000 21000 22000 23000 24000 25000 26000 27000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.17 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 370 280) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "key[pitch selection]" (om-load-patch-abs1 "key[pitch selection]" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 50 7343/36) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "all_rots" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 3289/6 291/2) nil nil nil (list (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "Patch made by $Nigel McBride ") "" (om-make-point 41 408) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:italic)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 377 359) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 411 72) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ROTATE" (quote rotate) (quote ((om-load-inputfun (quote input-funbox) "the list" "LIST" nil) (om-load-inputfun (quote input-funbox) "nth" "NTH" 1))) (om-make-point 380 269) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 64 38) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 487 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 467 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 494 494) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 260 491) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 1 0 nil 0) (4 0 2 0 nil 0) (4 0 3 0 nil 0) (6 0 3 1 nil 0) (2 0 5 0 nil 0) (5 0 6 1 nil 0) (1 1 7 0 nil 0) (1 0 8 0 nil 0))) 1 "all_rots" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 1144/3 128) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 8" (quote list) (quote nil) (om-make-point 1081/3 50) (om-make-point 151 28) (list 200 200 100 200 200 200) "(200 200 100 200 200 200)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 10" (quote list) (quote nil) (om-make-point 856/3 65) (om-make-point 35 28) 6200 "6200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 1372/3 251) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 11" (quote list) (quote nil) (om-make-point 949/3 218) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 12" (quote list) (quote nil) (om-make-point 1606/3 56) (om-make-point 161 28) (list 200 100 200 200 100 200) "(200 100 200 200 100 200)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 13" (quote list) (quote nil) (om-make-point 886/3 123) (om-make-point 35 28) 6400 "6400" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ 2" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 892/3 368) (om-make-point 459 122) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((6400) (6600) (6700) (6900) (7100) (7200) (7400))) :lonset (quote (0 1000 2000 3000 4000 5000 6000 7000)) :ldur (quote ((1000) (1000) (1000) (1000) (1000) (1000) (1000))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.17 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote g) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :osc-scoreplayer) 1 nil 1000 0 (om-make-point 728 260) (om-make-point 400 20) 0 1 (quote :normal) (quote t) nil)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((5 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 2 0 nil 0) (3 0 2 1 nil 0) (6 0 5 0 nil 0) (1 0 5 1 nil 0) (2 0 9 1 nil 0))) 6.17 nil "" (om-make-point -8 -8) (om-make-point 1280 637)) (quote nil) (om-make-point 50057/54 577/18) nil (list (list 6200 6400 6600 6700 6900 7100 7300)) nil "key[pitch selection]"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 14" (quote list) (quote nil) (om-make-point 275 202) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "SAVE-AS-MIDI" (quote save-as-midi) (quote ((om-load-inputfun (quote input-funbox) "" "OBJECT" nil))) (om-make-point 98 438) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "PatternSelection" (om-load-patch-abs1 "PatternSelection" (quote ((let ((box (om-load-boxin "input 7" 6 (om-make-point 408 35) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 551/3 19655/36) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 6" 5 (om-make-point 320 240) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 5" 4 (om-make-point 276 242) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 4" 3 (om-make-point 183 229) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 130 234) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 37 228) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 0 227) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "removenil" (om-load-patch-abs1 "removenil" (quote ((let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.17 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (x) (remove nil x))") (quote ((om-load-inputfun (quote input-funbox) "" "X" nil))) (om-make-point 380 311) nil nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CONS 2" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "CAR" "CAR" nil) (om-load-inputfun (quote input-funbox) "CDR" "CDR" nil))) (om-make-point 206 179) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CONS" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "CAR" "CAR" nil) (om-load-inputfun (quote input-funbox) "CDR" "CDR" nil))) (om-make-point 92 135) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 68 398) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 6359/24 1309/24) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 9763/72 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 677/12) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 267/2 2657/12) (om-make-point 137 58) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((7 0 0 0 nil 0) (2 0 1 0 nil 0) (4 0 1 1 nil 0) (6 0 2 0 nil 0) (5 0 2 1 nil 0) (0 0 3 0 nil 0) (1 0 7 0 nil 0))) 6.17 nil "" (om-make-point 200 200) (om-make-point 500 380)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 355/2 459) nil (list (list 1 2 3 6 11 23 47 106 235)) nil "removenil"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "rotatenth||reverse" (om-load-patch-abs1 "rotatenth||reverse" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 56 512) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 163 443) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CONS" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "CAR" "CAR" nil) (om-load-inputfun (quote input-funbox) "CDR" "CDR" nil))) (om-make-point 87 395) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "NTH-RANDOM" (quote nth-random) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" nil))) (om-make-point 318 446) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 1))) (om-make-point 361 363) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 416 319) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 348 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 201 63) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 64 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 195) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 2" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 1))) (om-make-point 94 262) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF 2" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (quote t)))) (om-make-point 104 323) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 1))) (om-make-point 52 261) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (quote t)))) (om-make-point 63 321) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NTH" (quote nth) (quote ((om-load-inputfun (quote input-funbox) "ORIG-N" "ORIG-N" nil) (om-load-inputfun (quote input-funbox) "ORIG-LIST" "ORIG-LIST" nil))) (om-make-point 170 267) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 1253/6 581/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "all_rots" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 1415/6 293/2) nil nil nil (list (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "Patch made by $Nigel McBride ") "" (om-make-point 41 408) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:italic)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 377 359) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 411 72) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ROTATE" (quote rotate) (quote ((om-load-inputfun (quote input-funbox) "the list" "LIST" nil) (om-load-inputfun (quote input-funbox) "nth" "NTH" 1))) (om-make-point 380 269) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 64 38) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 487 113) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 467 186) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 494 494) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 260 491) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((3 0 1 0 nil 0) (4 0 2 0 nil 0) (4 0 3 0 nil 0) (6 0 3 1 nil 0) (2 0 5 0 nil 0) (5 0 6 1 nil 0) (1 1 7 0 nil 0) (1 0 8 0 nil 0))) 1 "all_rots" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 0 0 nil 0) (2 0 1 0 nil 0) (13 0 2 0 nil 0) (11 0 2 1 nil 0) (4 0 3 0 nil 0) (5 0 4 1 nil 0) (6 0 5 0 nil 0) (16 0 6 0 nil 0) (8 0 10 0 nil 0) (10 0 11 0 nil 0) (15 0 11 1 nil 0) (9 0 12 0 nil 0) (12 0 13 0 nil 0) (14 0 13 1 nil 0) (3 0 14 0 nil 0) (16 0 14 1 nil 0) (14 0 15 0 nil 0) (7 0 16 0 nil 0))) 6.17 nil "" (om-make-point -8 -8) (om-make-point 1280 597)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 7259/24 2793/8) nil (list (list nil)) nil "rotatenth||reverse"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "original" (om-load-patch-abs1 "original" (quote ((let ((box (om-load-boxin "input 3" 2 (om-make-point 220 69) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 1817/6 429/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 2" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 1))) (om-make-point 239 227) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF 2" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (quote t)))) (om-make-point 250 287) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CONS" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "CAR" "CAR" nil) (om-load-inputfun (quote input-funbox) "CDR" "CDR" nil))) (om-make-point 213 339) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 93 414) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 152 125) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 139) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (quote t)))) (om-make-point 98 290) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 1))) (om-make-point 87 230) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (6 0 2 0 nil 0) (2 0 3 0 nil 0) (1 0 3 1 nil 0) (8 0 4 0 nil 0) (3 0 4 1 nil 0) (4 0 5 0 nil 0) (9 0 8 0 nil 0) (0 0 8 1 nil 0) (7 0 9 0 nil 0))) 6.17 nil "" (om-make-point -8 -8) (om-make-point 1280 597)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 97/2 354) nil (list (list 1 2 3 6 11 23 47 106 235)) nil "original"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "invert||reverse" (om-load-patch-abs1 "invert||reverse" (quote ((let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 326 426) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CONS" (quote cons) (quote ((om-load-inputfun (quote input-funbox) "CAR" "CAR" nil) (om-load-inputfun (quote input-funbox) "CDR" "CDR" nil))) (om-make-point 93 414) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 107 483) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 182 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 94 173) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 174) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF 2" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (quote t)))) (om-make-point 130 362) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM= 2" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 1))) (om-make-point 119 302) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OMIF" (quote omif) (quote ((om-load-inputfun (quote input-funbox) "IF" "TEST" nil) (om-load-inputfun (quote input-funbox) "THEN" "ACTION" (quote t)))) (om-make-point 80 342) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM=" (quote om=) (quote ((om-load-inputfun (quote input-funbox) "a number" "A" 0) (om-load-inputfun (quote input-funbox) "a number" "B" 1))) (om-make-point 69 282) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "inversion" (om-load-patch-abs1 "inversion" (quote ((let ((box (om-load-boxout "output" 0 (om-make-point 5 240) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X->DX" (quote x->dx) (quote ((om-load-inputfun (quote input-funbox) "a list of numbers" "SELF" (list 0 1)))) (om-make-point 270 150) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "SELF" 0) (om-load-inputfun (quote input-funbox) "number or list" "NUM" -1))) (om-make-point 316 267) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "DX->X" (quote dx->x) (quote ((om-load-inputfun (quote input-funbox) "a number" "START" 0) (om-load-inputfun (quote input-funbox) "a list of numbers" "LIST" (list 1 1)))) (om-make-point 254 302) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FIRST" (quote first) (quote ((om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 219 241) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((4 0 0 0 nil 0) (1 0 2 0 nil 0) (2 0 3 0 nil 0) (5 0 4 0 nil 0) (3 0 4 1 nil 0) (1 0 5 0 nil 0))) 6.17 nil "" (om-make-point 200 200) (om-make-point 500 400)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 535/4 171) nil (list (list 1 0 -1 -4 -9 -21 -45 -104 -233)) nil "inversion"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "REVERSE 2" (quote reverse) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 1097/6 579/2) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((1 0 0 0 nil 0) (8 0 1 0 nil 0) (6 0 1 1 nil 0) (1 0 2 0 nil 0) (7 0 6 0 nil 0) (11 0 6 1 nil 0) (4 0 7 0 nil 0) (9 0 8 0 nil 0) (10 0 8 1 nil 0) (5 0 9 0 nil 0) (3 0 10 0 nil 0) (10 0 11 0 nil 0))) 6.17 nil "" (om-make-point 200 200) (om-make-point 500 300)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 11887/72 4039/12) nil (list (list nil)) nil "invert||reverse"))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((8 0 1 0 nil 0) (10 0 8 0 nil 0) (11 0 8 1 nil 0) (9 0 8 2 nil 0) (3 0 9 0 nil 0) (2 0 9 1 nil 0) (0 0 9 2 nil 0) (7 0 10 0 nil 0) (6 0 10 1 nil 0) (0 0 10 2 nil 0) (5 0 11 0 nil 0) (4 0 11 1 nil 0) (0 0 11 2 nil 0))) 6.17 nil "" (om-make-point -8 -8) (om-make-point 1280 317)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil) (om-load-inputfun (quote input-funbox) "" "input 4" nil) (om-load-inputfun (quote input-funbox) "" "input 5" nil) (om-load-inputfun (quote input-funbox) "" "input 6" nil) (om-load-inputfun (quote input-funbox) "" "input 7" nil))) (om-make-point 1177/18 25769/96) (om-make-point 260 66) (list (list 1 2 3 6 11 23 47 106 235 235 106 47 23 11 6 3 2 1 -233 -104 -45 -21 -9 -4 -1 0 1)) nil "PatternSelection"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 41 168) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 161 178) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 241 201) (om-make-point 26 28) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 206 181) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 90 168) (om-make-point 26 28) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 3" (om-make-point 100 60) (quote "depth") "" (om-make-point 615 69) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment 2" (om-make-point 100 60) (quote "freq ") "" (om-make-point 427 16) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcomment "comment" (om-make-point 100 60) (quote "x") "" (om-make-point 84 35) nil (om-make-color 0 0 0) (om-make-font "Verdana" 12 :family "Verdana" :style (quote (:plain)) :mode (quote nil))))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 560 54) (om-make-point 26 28) 2 "2" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 388 39) (om-make-point 26 28) 3 "3" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "BaroqueFlute2" (om-load-patch-abs1 "BaroqueFlute2" (quote ((let ((box (om-load-boxin "input 4" 3 (om-make-point 1059 21) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 915 369) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 798 350) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 794 281) (om-make-point 54 58) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 813 230) (om-make-point 38 36) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 780 152) (om-make-point 39 28) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH 2" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 849 168) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 207 49) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "FLOOR" (quote floor) (quote ((om-load-inputfun (quote input-funbox) "M" "M" nil))) (om-make-point 56 232) nil nil "l" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAPCAR" (quote mapcar) (quote ((om-load-inputfun (quote input-funbox) "FUNCTION" "FUNCTION" nil) (om-load-inputfun (quote input-funbox) "LIST" "LIST" nil))) (om-make-point 88 333) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM* 2" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1000))) (om-make-point 164 326) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output 2" 1 (om-make-point 81 462) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 594 527) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 142 52) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 50 50) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxwithed1 (quote box-with-win) "pnoise" (quote omloop) (quote ((om-load-inputfun (quote input-funbox) "" "input0" nil) (om-load-inputfun (quote input-funbox) "" "input1" nil) (om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 143 160) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "PERLIN-NOISE" (quote perlin-noise) (quote ((om-load-inputfun (quote input-funbox) "yet another test" "ARG1" 10) (om-load-inputfun (quote input-funbox) "yet another test" "ARG2" 10) (om-load-inputfun (quote input-funbox) "yet another test" "ARG3" 4) (om-load-inputfun (quote input-funbox) "yet another test" "ARG4" 4))) (om-make-point 91 255) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "aux" (quote t) (quote nil) (om-make-point 80 132) (om-make-point 33 28) 10 "10" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 2 (om-make-point 190 46) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input1" 1 (om-make-point 109 38) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input0" 0 (om-make-point 5 40) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "collect" (quote listing) (quote ((om-load-inputfun (quote input-funbox) "anything" "DATA" nil))) (om-make-point 460 316) nil nil nil nil 3))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 10 160) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 496 425) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 396 425) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote ((6 0 0 0 nil 0) (1 0 0 1 nil 0) (3 0 0 2 nil 0) (2 0 0 3 nil 0) (0 0 5 0 nil 0) (4 0 6 0 nil 0) (5 1 7 0 nil 0) (5 0 8 0 nil 0))) 1 "pnoise" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "BaroqueFlutePitchRange 2" (om-load-patch-abs1 "BaroqueFlutePitchRange" (quote ((let ((box (om-load-boxcall (quote lispfun) "LENGTH 2" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 381 119) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 409/2 7293/16) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 0 102) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "ARITHM-SER" (quote arithm-ser) (quote ((om-load-inputfun (quote input-funbox) "begin" "BEGIN" 0) (om-load-inputfun (quote input-funbox) "end " "END" 10) (om-load-inputfun (quote input-funbox) "step" "STEP" 100))) (om-make-point 199 94) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 198 36) (om-make-point 35 28) 6200 "6200" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 238 35) (om-make-point 35 28) 9300 "9300" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "LENGTH" (quote length) (quote ((om-load-inputfun (quote input-funbox) "SEQUENCE" "SEQUENCE" nil))) (om-make-point 117 143) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 90 173) (om-make-point 39 28) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM/" (quote om/) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 1) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 1))) (om-make-point 89 213) (om-make-point 38 36) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM//" (quote om//) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1) (om-load-inputfun (quote input-funbox) "number or list" "DIVISOR" 1))) (om-make-point 70 264) (om-make-point 54 58) nil nil nil 2))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "FLAT" (quote flat) (quote ((om-load-inputfun (quote input-funbox) "a list" "LST" nil))) (om-make-point 74 333) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "POSN-MATCH" (quote posn-match) (quote ((om-load-inputfun (quote input-funbox) "a list" "LIST" (list 10 20 30 40 50 60 70 80 90)) (om-load-inputfun (quote input-funbox) "a list positions" "POSITIONS" (list (list 0 1) 4 (list 6))))) (om-make-point 192 353) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((3 0 0 0 nil 0) (11 0 1 0 nil 0) (4 0 3 0 nil 0) (5 0 3 1 nil 0) (3 0 6 0 nil 0) (7 0 8 0 nil 0) (6 0 8 1 nil 0) (2 0 9 0 nil 0) (8 0 9 1 nil 0) (9 0 10 0 nil 0) (3 0 11 0 nil 0) (10 0 11 1 nil 0))) 6.17 nil "" (om-make-point -8 -8) (om-make-point 1280 557)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil))) (om-make-point 3344/3 2168/9) nil (list (list 8500 6700 8100 7200 8800 7300 7600 8600 8100)) nil "BaroqueFlutePitchRange"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-ROUND" (quote om-round) (quote ((om-load-inputfun (quote input-funbox) "number or list" "N" 1))) (om-make-point 605 149) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 100) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 444 153) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((0 0 1 0 nil 0) (2 0 1 1 nil 0) (3 0 2 0 nil 0) (17 0 3 0 nil 0) (4 0 3 1 nil 0) (5 0 4 0 nil 0) (6 0 4 1 nil 0) (0 0 6 0 nil 0) (8 0 9 0 nil 0) (10 0 9 1 nil 0) (15 0 10 0 nil 0) (9 0 11 0 nil 0) (1 0 12 0 nil 0) (14 0 15 0 nil 0) (13 0 15 1 nil 0) (7 0 15 2 nil 0) (18 0 17 0 nil 0) (15 0 18 1 nil 0))) 6.17 nil "" (om-make-point -8 -8) (om-make-point 1280 537)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil) (om-load-inputfun (quote input-funbox) "" "input 4" nil))) (om-make-point 1481/3 6911/36) nil (list (list 3600 2600 5100 6800 6600 5400 5600 3900 5200 5200 3900 5600 5400 6600 6800 5100 2600 3600 3100 4800 3800 5600 5900 5500 5400 3300 3600) (list 364 210 569 816 792 620 652 402 589 589 402 652 620 792 816 569 210 364 275 531 390 636 685 626 608 309 364)) nil "BaroqueFlute2"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "quantize 2" (om-load-patch-abs1 "quantize" (quote ((let ((box (om-load-boxwithed1 (quote box-with-win) "OMLOOP" (quote omloop) (quote nil) (om-make-point 517 211) nil nil nil (list (let ((box (om-load-boxcall (quote genfun) "inlist" (quote listloop) (quote ((om-load-inputfun (quote input-funbox) "list to iterate" "LIST" nil))) (om-make-point 185 100) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "while" (quote whileloop) (quote ((om-load-inputfun (quote input-funbox) "condition" "EXPR" nil))) (om-make-point 60 94) nil nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "for" (quote forloop) (quote ((om-load-inputfun (quote input-funbox) "low value" "FROM" 0) (om-load-inputfun (quote input-funbox) "high value" "TO" 10))) (om-make-point 5 80) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "finally" (quote finaldo) (quote ((om-load-inputfun (quote input-funbox) "value to return" "VAL" nil))) (om-make-point 300 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-seqbox "eachTime" (quote loopdo) (quote ((om-load-inputfun (quote input-funbox) "operations to do" "OP" nil))) (om-make-point 200 250) nil nil nil 0))) (when (fboundp (quote set-active)) (set-active box nil)) box)) (quote nil) 1 "omloop" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote abstraction) "lispfunction" (om-load-lisp-abspatch "lispfunction" 6.17 ";;; Edit a valid LAMBDA EXPRESSION for \"lispfunction\"$;;; e.g. (lambda (arg1 arg2 ...) ( ... ))$$(lambda (list) (loop :for x :in list :sum x :into y :collect y))$") (quote ((om-load-inputfun (quote input-funbox) "" "LIST" nil))) (om-make-point 195 149) nil (list (list 245 337 561 806)) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "X-APPEND" (quote x-append) (quote ((om-load-inputfun (quote input-funbox) "first element" "L1?" 0) (om-load-inputfun (quote input-funbox) "second element" "L2?" nil))) (om-make-point 201 230) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 2))) (om-make-point 262 266) (om-make-point 40 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxout "output" 0 (om-make-point 322 581) (quote ((om-load-inputfun (quote input-funbox) "" "out" nil))) nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 3" 2 (om-make-point 268 49) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input 2" 1 (om-make-point 156 54) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxin "input" 0 (om-make-point 218/3 899/9) "" nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 68 354) (om-make-point 243 168) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((8200) (7800) (9200) (8900) (6300) (8200) (6300))) :lonset (quote (0 167 295 540 757 766 929 938)) :ldur (quote ((167) (128) (245) (217) (9) (163) (9))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj) nil nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point 400 20) (om-make-point 370 280) 0 1000 nil 1 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote g) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((6 0 1 0 nil 0) (1 0 2 1 nil 0) (2 0 3 0 nil 0) (5 0 3 1 nil 0) (8 0 4 0 nil 0) (7 0 8 1 nil 0) (3 0 8 2 nil 0) (6 0 8 3 nil 0))) 6.17 nil "" (om-make-point -8 -8) (om-make-point 1280 577)) (quote ((om-load-inputfun (quote input-funbox) "" "input" nil) (om-load-inputfun (quote input-funbox) "" "input 2" nil) (om-load-inputfun (quote input-funbox) "" "input 3" nil))) (om-make-point 30827/60 5929/20) nil (list (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((3600) (2600) (5100) (6800) (6600) (5400) (5600) (3900) (5200) (5200) (3900) (5600) (5400) (6600) (6800) (5100) (2600) (3600) (3100) (4800) (3800) (5600) (5900) (5500) (5400) (3300) (3600))) :lonset (quote (0 182 287 572 980 1376 1686 2012 2212 2507 2802 3002 3328 3638 4034 4442 4727 4832 5014 5152 5417 5612 5930 6272 6586 6890 7044 7408)) :ldur (quote ((364) (210) (569) (816) (792) (620) (652) (402) (589) (589) (402) (652) (620) (792) (816) (569) (210) (364) (275) (531) (390) (636) (685) (626) (608) (309) (364))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote nil)) (set-name newobj nil) (set-tonalite newobj nil) newobj)) nil "quantize"))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 9" (quote list) (quote nil) (om-make-point 152 31) (om-make-point 159 28) (list 1 2 3 6 11 23 47 106 235) "(1 2 3 6 11 23 47 106 235)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "CHORD-SEQ" (quote chord-seq) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "pitches (mc): list or list of lists" "lmidic" (list 6000)) (om-load-inputfun (quote input-funbox) "onsets (ms): list" "lonset" (list 0 1000)) (om-load-inputfun (quote input-funbox) "durations (ms): list or list of lists" "ldur" (list 1000)) (om-load-inputfun (quote input-funbox) "velocities (0-127): list or list of lists" "lvel" (list 100)) (om-load-inputfun (quote input-funbox) "offsets (ms): list or list of lists" "loffset" (list 0)) (om-load-inputfun (quote input-funbox) "MIDI channels (1-16): list or list of lists" "lchan" (list 1)) (om-load-inputfun (quote input-funbox) "relative chords duration (0-100)" "legato" 0))) (om-make-point 342 392) (om-make-point 342 169) (let ((newobj (when (find-class (quote chord-seq) nil) (make-instance (quote chord-seq) :lmidic (quote ((3600) (2600) (5100) (6800) (6600) (5400) (5600) (3900) (5200) (5200) (3900) (5600) (5400) (6600) (6800) (5100) (2600) (3600) (3100) (4800) (3800) (5600) (5900) (5500) (5400) (3300) (3600))) :lonset (quote (0 182 287 572 980 1376 1686 2012 2212 2507 2802 3002 3328 3638 4034 4442 4727 4832 5014 5152 5417 5612 5930 6272 6586 6890 7044 7408)) :ldur (quote ((364) (210) (569) (816) (792) (620) (652) (402) (589) (589) (402) (652) (620) (792) (816) (569) (210) (364) (275) (531) (390) (636) (685) (626) (608) (309) (364))) :lvel (quote ((100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100) (100))) :loffset (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0))) :lchan (quote ((1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1))) :legato 0)))) (load-port-info newobj (quote ((0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0) (0)))) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 6.17 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (scale show-stems cursor-mode obj-mode score-mode winpos winsize mode grillestep notechancolor? zoom player inport outport deltapict cmnpref staff fontsize approx)) (list nil (quote t) (quote :normal) 1 0 (om-make-point -8 -8) (om-make-point 1280 617) 0 1000 nil 1 (quote :osc-scoreplayer) nil nil (om-make-point 0 0) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (quote gf) 24 2)) t nil nil nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 591 243) (om-make-point 36 28) 0.5 "0.5" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 1 2 nil 0) (0 0 2 0 nil 0) (21 0 2 1 nil 0) (20 0 2 2 nil 0) (25 1 4 1 nil 0) (25 2 4 2 nil 0) (25 3 4 3 nil 0) (3 0 4 6 nil 0) (22 0 7 1 nil 0) (25 0 10 0 nil 0) (12 0 11 0 nil 0) (16 0 11 1 nil 0) (13 0 11 2 nil 0) (15 0 11 3 nil 0) (14 0 11 4 nil 0) (9 0 11 5 nil 0) (24 0 11 6 nil 0) (11 0 22 0 nil 0) (21 0 22 1 nil 0) (20 0 22 2 nil 0) (6 0 22 3 nil 0) (22 0 23 0 nil 0) (22 1 23 1 nil 0) (26 0 23 2 nil 0) (23 0 25 0 nil 0) (5 0 25 6 nil 0))) nil 6.17))
